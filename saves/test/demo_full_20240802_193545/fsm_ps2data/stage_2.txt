############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
1. Your task is to write a verilog testbench for an verilog RTL module code (we call it as "DUT", device under test). The infomation we have is the problem description that guides student to write the RTL code (DUT) and the header of the "DUT". Our target is to generate the verilog testbench for the DUT. This testbench can check if the DUT in verilog satisfies all technical requirements of the problem description.
2. you are in section 2. in this section, please give me the test scenarios. you only need to describe the stimulus in each test scenarios. If time is important, please inform the clock cycle information. we will use the stimulus description to generate the test vectors and send them to DUT. you must not tell the expected results even though you know that. 
3. your information is:
RTL circuit problem description:
We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received.

// Implement the datapath module that will output the 24-bit (3 byte) message whenever a packet is received (out_bytes[23:16] is the first byte, out_bytes[15:8] is the second byte, etc.). The reset signal is active high synchronous. out_bytes needs to be valid whenever the done signal is asserted. You may output anything at other times (i.e., don't-care). 

// Waveform example:
// time            clk             reset           in[7:0]         done            out_bytes       
// 0ns             0               1                0              x                    x          
// 5ns             1               1                0              0                    x          
// 10ns            0               1                0              0                    x          
// 15ns            1               0               2c              0                    x          
// 20ns            0               0               2c              0                    x          
// 25ns            1               0               81              0                    x          
// 30ns            0               0               81              0                    x          
// 35ns            1               0                9              0                    x          
// 40ns            0               0                9              0                    x          
// 45ns            1               0               6b              1               2c8109          
// 50ns            0               0               6b              1               2c8109          
// 55ns            1               0                d              0                    x          
// 60ns            0               0                d              0                    x          
// 65ns            1               0               8d              0                    x          
// 70ns            0               0               8d              0                    x          
// 75ns            1               0               6d              1               6b0d8d          
// 80ns            0               0               6d              1               6b0d8d          
// 85ns            1               0               12              0                    x          
// 90ns            0               0               12              0                    x          
// 95ns            1               0                1              0                    x          
// 100ns           0               0                1              0                    x          
// 105ns           1               0                d              1               6d1201          
// 110ns           0               0                d              1               6d1201          
// 115ns           1               0               76              0                    x          
// 120ns           0               0               76              0                    x          
// 125ns           1               0               3d              0                    x          
// 130ns           0               0               3d              0                    x          
// 135ns           1               0               ed              1                d763d          
// 140ns           0               0               ed              1                d763d          
// 145ns           1               0               8c              0                    x          
// 150ns           0               0               8c              0                    x          
// 155ns           1               0               f9              0                    x          
// 160ns           0               0               f9              0                    x          
// 165ns           1               0               ce              1               ed8cf9          
// 170ns           0               0               ce              1               ed8cf9          
// 175ns           1               0               c5              0                    x          
// 180ns           0               0               c5              0                    x          
// 185ns           1               0               aa              0                    x          
// 190ns           0               0               aa              0                    x          
RTL testbench specification:
{
  "important data": "DUT module processes an 8-bit input stream to identify message boundaries based on the condition in[3]=1 and outputs a 24-bit message whenever fully received, with a synchronous reset mechanism.",
  "technical specifications": [
    "0: The DUT module named top_module has the following input/output parameters: inputs are clk (1-bit), in (8-bit), reset (1-bit); outputs are out_bytes (24-bit) and done (1-bit).",
    "1: The finite state machine shall discard input bytes until an input byte with in[3]=1 is detected.",
    "2: The DUT will generate a valid out_bytes signal when 3 bytes of data are received in accordance with the message boundaries specified.",
    "3: The reset signal is active high and synchronous, meaning that the DUT behavior will be reset on the rising edge of the reset signal.",
    "4: The output signal done will be asserted in the cycle immediately after the third byte of the message has been successfully received.",
    "5: The values of out_bytes need to remain valid whenever the done signal is asserted, and can be ignored (donâ€™t care) at other times.",
    "6: Input test cases must cover various scenarios including no valid start byte, received message bytes, and changing reset state."
  ]
}
DUT header:
module top_module (
	input clk,
	input [7:0] in,
	input reset,
	output [23:0] out_bytes,
	output done
);


you only need to describe the stimulus in each test scenarios. If time is important, please inform the clock cycle information. we will use the stimulus description to generate the test vectors and send them to DUT. you must not tell the expected results even though you know that. 

your response must be in JSON form. example:
{
  "scenario 1": "...", # each content is a string
  "scenario 2": "...",
  "scenario 3": "...",
  ...
}


########## assistant ##########
{
  "scenario 1": "Reset the DUT at time 0ns with reset signal high and provide no input stream. Observe behavior until reset signal goes low.",
  "scenario 2": "After releasing reset at 5ns, send a series of bytes with in[3]=0. Continue until a byte with in[3]=1 is sent. Verify that done signal remains low.",
  "scenario 3": "At 25ns, input the byte 0b00001000 (in[3]=1) followed by two valid message bytes (e.g., 0b00000001 and 0b00000010) to complete the message. Check if done is asserted immediately after third byte.",
  "scenario 4": "At 60ns, input an additional byte that does not match the message criteria (in[3]=0), then resume valid inputs. Check if the DUT correctly ignores this byte.",
  "scenario 5": "Introduce a reset signal at 65ns while inputting bytes to confirm DUT behavior resets. Release reset after a few clock cycles to observe if the DUT properly reinitializes.",
  "scenario 6": "Send two full messages sequentially starting at 75ns. The first message should start with a valid byte (in[3]=1) and consist of three message bytes. Immediately follow with another start byte and two bytes. Monitor done signals for both messages.",
  "scenario 7": "At 135ns, input a byte with in[3]=1 directly after applying reset to confirm that the DUT can still detect the message start right after a reset.",
  "scenario 8": "Input an invalid byte stream consisting solely of in[3]=0 bytes over a long cycle (e.g., 100ns) to verify that the DUT does not assert done and manages to discard invalid inputs.",
  "scenario 9": "At 150ns, input a byte followed by a reset and monitor the out_bytes to ensure it does not hold any data after a reset."
}

