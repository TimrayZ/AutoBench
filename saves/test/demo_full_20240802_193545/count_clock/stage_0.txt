############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
Please generate the verilog RTL code according to the following description and header information:
problem description:
Create a set of counters suitable for use as a 12-hour clock (with am/pm indicator). Your counters are clocked by a fast-running clk, with a pulse on ena whenever your clock should increment (i.e., once per second, while "clk" is much faster than once per second). The signal "pm" is asserted if the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD (Binary-Coded Decimal) digits each for hours (01-12), minutes (00-59), and seconds (00-59). Reset is the active high synchronous signal that resets the clock to "12:00 AM." Reset has higher priority than enable and can occur even when not enabled.
RTL header:
module top_module(
	input clk,
	input reset,
	input ena,
	output reg pm,
	output reg [7:0] hh,
	output reg [7:0] mm,
	output reg [7:0] ss);

please only reply verilog codes. reply_format:
```verilog
your_code_here...
```


########## assistant ##########
```verilog
module top_module(
    input clk,
    input reset,
    input ena,
    output reg pm,
    output reg [7:0] hh,
    output reg [7:0] mm,
    output reg [7:0] ss
);

    reg [5:0] sec_count;
    reg [5:0] min_count;
    reg [3:0] hour_count;

    always @(posedge clk) begin
        if (reset) begin
            hh <= 8'b00010000; // Starts at 12 (BCD: 0001 0010)
            mm <= 8'b00000000; // 00 minutes
            ss <= 8'b00000000; // 00 seconds
            pm <= 1'b0;        // Start as AM
            sec_count <= 6'b000000;
            min_count <= 6'b000000;
            hour_count <= 4'b0000; // '0' means 12 in the context
        end
        else if (ena) begin
            // Increment seconds
            if (sec_count < 6'd59) begin
                sec_count <= sec_count + 1;
            end else begin
                sec_count <= 6'd0; // Reset seconds count
                // Increment minutes
                if (min_count < 6'd59) begin
                    min_count <= min_count + 1;
                end else begin
                    min_count <= 6'd0; // Reset minutes count
                    // Increment hours
                    if (hour_count < 4'b1100) begin // 12 in BCD
                        if (hour_count == 4'b1010) begin // 10 in BCD
                            hour_count <= hour_count + 1; // Increment to 11
                        end else begin
                            hour_count <= hour_count + 1; // Increment hour
                        end
                    end else begin
                        hour_count <= 4'b0000; // Reset to 0
                        pm <= ~pm; // Toggle AM/PM
                    end
                end
            end

            // BCD conversion
            if (hour_count < 4'b1010) // 0-9
                hh <= {4'b0000, hour_count};
            else // 10-12
                hh <= {4'b0001, hour_count[2:0]}; // Convert 10, 11 to BCD 

            mm <= {4'b0000, min_count}; // Minutes in BCD
            ss <= {4'b0000, sec_count}; // Seconds in BCD
        end
    end
endmodule
```

