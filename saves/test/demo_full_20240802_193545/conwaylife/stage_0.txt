############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
Please generate the verilog RTL code according to the following description and header information:
problem description:
The "game" is played on a two-dimensional grid of cells, where each cell is either 1 (alive) or 0 (dead). At each time step, each cell changes state depending on how many neighbours it has:
// (1) 0-1 neighbour: Cell becomes 0.
// (2) 2 neighbours: Cell state does not change.
// (3) 3 neighbours: Cell becomes 1.
// (4) 4+ neighbours: Cell becomes 0.
// The game is formulated for an infinite grid. In this circuit, we will use a 16x16 grid. To make things more interesting, we will use a 16x16 toroid, where the sides wrap around to the other side of the grid. For example, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15), (0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by a length 256 vector, where each row of 16 cells is represented by a sub-vector: q[15:0] is row 0, q[31:16] is row 1, etc. 
// (1) load: Loads data into q at the next clock edge, for loading initial state. Active high synchronous.
// (2) q: The 16x16 current state of the game, updated every clock cycle.
// The game state should advance by one timestep every clock cycle.
RTL header:
module top_module(
	input clk,
	input load,
	input [255:0] data,
	output reg [255:0] q);

please only reply verilog codes. reply_format:
```verilog
your_code_here...
```


########## assistant ##########
```verilog
module top_module(
    input clk,
    input load,
    input [255:0] data,
    output reg [255:0] q
);
    
    reg [255:0] next_q; // Next state of the grid

    // Function to count the number of alive neighbors
    function [3:0] count_neighbors(input [255:0] grid, input [3:0] row, input [3:0] col);
        integer neighbor_count;
        integer r, c;
        neighbor_count = 0;
        for (r = -1; r <= 1; r = r + 1) begin
            for (c = -1; c <= 1; c = c + 1) begin
                if (!(r == 0 && c == 0)) begin // Exclude the cell itself
                    neighbor_count = neighbor_count + grid[((row + r + 16) % 16) * 16 + ((col + c + 16) % 16)];
                end
            end
        end
        count_neighbors = neighbor_count;
    endfunction

    // Update state logic
    always @* begin
        next_q = q; // Default to current state
        for (integer i = 0; i < 16; i = i + 1) begin
            for (integer j = 0; j < 16; j = j + 1) begin
                case (count_neighbors(q, i, j))
                    1: next_q[i * 16 + j] = 0;   // Case (1): 0-1 neighbors -> 0
                    2: next_q[i * 16 + j] = q[i * 16 + j]; // Case (2): 2 neighbors -> unchanged
                    3: next_q[i * 16 + j] = 1;   // Case (3): 3 neighbors -> 1
                    default: next_q[i * 16 + j] = 0; // Case (4): 4+ neighbors -> 0
                endcase
            end
        end
    end

    // State update on clock edge
    always @(posedge clk) begin
        if (load) begin
            q <= data; // Load initial state
        end else begin
            q <= next_q; // Update state
        end
    end
    
endmodule
```

