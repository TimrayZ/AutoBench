############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########

1. Your task is to complete a given verilog testbench code. This testbench is for a verilog RTL module code (we call it as "DUT", device under test). This circuit is a sequential circuit. The infomation we have is 
- 1.1. the problem description that guides student to write the RTL code (DUT) and the header of the "DUT". 
- 1.2. the module header.
- 1.3. test scenarios which determines values and sequential information of test vectors
- 1.4. the testbench structure
- 1.5. the instruction of writing our testbench

DUT header:
module top_module
(
    input clk,
    input areset,
    input predict_valid,
    input predict_taken,
    output logic [31:0] predict_history,
    
    input train_mispredicted,
    input train_taken,
    input [31:0] train_history
);

Your other information:
RTL circuit problem description:
Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.


IMPORTANT - test scenario (Please determine the values of input signals according to these test scenarios.):
{
  "scenario 1": "Apply an asynchronous reset signal. Set areset to 1 for one clock cycle, then set areset to 0. Observe the output for the reset state of predict_history.",
  
  "scenario 2": "Set areset to 0, then set predict_valid to 1 and predict_taken to 1. Wait for one clock cycle to observe the update in predict_history after the prediction is made (first prediction).",

  "scenario 3": "Set predict_valid to 1 and predict_taken to 0. Wait for one clock cycle. Observe the update in predict_history after the second prediction is made.",
  
  "scenario 4": "Set predict_valid to 1 and predict_taken to 1 again. Wait for one clock cycle to observe the update in predict_history with subsequent predictions.",
  
  "scenario 5": "Set predict_valid to 0, with train_mispredicted set to 1. Provide train_history with a sample value and train_taken with 1. Wait for one clock cycle. Observe the output of predict_history reflecting the update based on the misprediction.",
  
  "scenario 6": "Set both predict_valid and train_mispredicted to 1, with train_history set to specific value and train_taken set to 0. Wait for one clock cycle. Observe that the output of predict_history should reflect the misprediction state despite predict_valid being high.",
  
  "scenario 7": "Set areset to 0, then provide several cycles of predictions (e.g., predict_valid = 1, alternating predict_taken values). Wait for a total of four clock cycles. Observe the evolution of predict_history through multiple predictions.",
  
  "scenario 8": "Set areset to 0, after a series of predictions, set areset to 1 again for one clock cycle, then revert to areset = 0. Observe predict_history should revert to the initial reset state.",
  
  "scenario 9": "Provide a mix of predictions and mispredictions over several cycles (e.g., multiple cycles with varying predict_valid, train_mispredicted, predict_taken, and train_taken values), spaced by clock cycles. Observe how predict_history evolves amid these inputs."
}
below is the given testbench codes:
`timescale 1ns / 1ps
module testbench;
reg  clk;
reg  areset;
reg  predict_valid;
reg  predict_taken;
wire [31:0] predict_history;
reg  train_mispredicted;
reg  train_taken;
reg [31:0] train_history;

integer file, scenario;
// DUT instantiation
top_module DUT (
	.clk(clk),
	.areset(areset),
	.predict_valid(predict_valid),
	.predict_taken(predict_taken),
	.predict_history(predict_history),
	.train_mispredicted(train_mispredicted),
	.train_taken(train_taken),
	.train_history(train_history)
);
// Clock generation
initial begin
    clk = 0;
    forever #5 clk = ~clk;
end

initial begin
    file = $fopen("TBout.txt", "w");
end
// Scenario Based Test
initial begin

    // write your scenario checking codes here, according to scenario information

    $fclose(file);
    $finish;
end

endmodule


The testbench does not need to check the DUT's output but only export the signals of DUT. Please export the signals of DUT to a file named "TBout.txt" at the end of each scenario. The template is given below:
$fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
The variables are already declared. The clock signal is already prepared. This output will be used to check the correctness of the DUT's output later.
please only use "#10" as the delay when you need. If you need longer delay, you can use multiple "#10", such as "#10; #10; #10;". Avoid meaningless long delay in your code.
If you need a loop in a scenario to check multiple time points, use "repeat" loop. for exmaple:
```
// scenario x
scenario = x;
signal_1 = 1;
repeat(5) begin
    $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
    #10;
end
```
Please determine the input signal's exact values according to given test scenarios. 
Note: please complete the last initial code part (marked in the given testbench template). You should give me the completed full code. The testbench template above is to help you generate the code. You must use %d when exporting values.
please generate the full testbench code. please only reply verilog codes, no other words. 



########## assistant ##########
```verilog
`timescale 1ns / 1ps
module testbench;
reg  clk;
reg  areset;
reg  predict_valid;
reg  predict_taken;
wire [31:0] predict_history;
reg  train_mispredicted;
reg  train_taken;
reg [31:0] train_history;

integer file, scenario;
// DUT instantiation
top_module DUT (
	.clk(clk),
	.areset(areset),
	.predict_valid(predict_valid),
	.predict_taken(predict_taken),
	.predict_history(predict_history),
	.train_mispredicted(train_mispredicted),
	.train_taken(train_taken),
	.train_history(train_history)
);
// Clock generation
initial begin
    clk = 0;
    forever #5 clk = ~clk;
end

initial begin
    file = $fopen("TBout.txt", "w");
end
// Scenario Based Test
initial begin

    // Scenario 1
    scenario = 1;
    areset = 1;
    repeat(1) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end
    areset = 0;
    repeat(1) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end

    // Scenario 2
    scenario = 2;
    areset = 0;
    predict_valid = 1;
    predict_taken = 1;
    repeat(1) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end

    // Scenario 3
    scenario = 3;
    predict_valid = 1;
    predict_taken = 0;
    repeat(1) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end

    // Scenario 4
    scenario = 4;
    predict_valid = 1;
    predict_taken = 1;
    repeat(1) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end

    // Scenario 5
    scenario = 5;
    predict_valid = 0;
    train_mispredicted = 1;
    train_history = 32'h12345678; // Sample value
    train_taken = 1;
    repeat(1) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end

    // Scenario 6
    scenario = 6;
    predict_valid = 1;
    train_mispredicted = 1;
    train_history = 32'h87654321; // Specific value
    train_taken = 0;
    repeat(1) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end

    // Scenario 7
    scenario = 7;
    areset = 0;
    predict_valid = 1;
    train_mispredicted = 0;
    // Alternate predict_taken values
    repeat(4) begin
        predict_taken = ~predict_taken; // Toggle predict_taken
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end

    // Scenario 8
    scenario = 8;
    areset = 1;
    repeat(1) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end
    areset = 0;
    repeat(1) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end

    // Scenario 9
    scenario = 9;
    areset = 0;
    // Provide a mix of predictions and mispredictions
    repeat(5) begin
        predict_valid = $urandom_range(0, 1);
        train_mispredicted = $urandom_range(0, 1);
        predict_taken = $urandom_range(0, 1);
        train_taken = $urandom_range(0, 1);
        train_history = $urandom; // Random value
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_taken = %d, predict_history = %d, train_mispredicted = %d, train_taken = %d, train_history = %d", scenario, clk, areset, predict_valid, predict_taken, predict_history, train_mispredicted, train_taken, train_history);
        #10;
    end

    $fclose(file);
    $finish;
end

endmodule
```

