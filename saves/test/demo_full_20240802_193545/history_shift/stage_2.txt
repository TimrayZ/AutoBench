############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
1. Your task is to write a verilog testbench for an verilog RTL module code (we call it as "DUT", device under test). The infomation we have is the problem description that guides student to write the RTL code (DUT) and the header of the "DUT". Our target is to generate the verilog testbench for the DUT. This testbench can check if the DUT in verilog satisfies all technical requirements of the problem description.
2. you are in section 2. in this section, please give me the test scenarios. you only need to describe the stimulus in each test scenarios. If time is important, please inform the clock cycle information. we will use the stimulus description to generate the test vectors and send them to DUT. you must not tell the expected results even though you know that. 
3. your information is:
RTL circuit problem description:
Build a 32-bit global history shift register, including support for rolling back state in response to a pipeline flush caused by a branch misprediction. When a branch prediction is made (predict_valid = 1), shift in predict_taken from the LSB side to update the branch history for the predicted branch. (predict_history[0] is the direction of the youngest branch.) When a branch misprediction occurs (train_mispredicted = 1), load the branch history register with the history after the completion of the mispredicted branch. This is the history before the mispredicted branch (train_history) concatenated with the actual result of the branch (train_taken). If both a prediction and misprediction occur at the same time, the misprediction takes precedence, because the pipeline flush will also flush out the branch that is currently making a prediction. predict_history is the value of the branch history register. areset is a positive edge triggered asynchronous reset that resets the history counter to zero.


RTL testbench specification:
{
  "important data": "",
  "technical specifications": [
    "1. The DUT is a 32-bit global history shift register that updates its state based on branch predictions and mispredictions.",
    "2. The DUT has the following inputs: clk (clock signal), areset (asynchronous reset), predict_valid (indicates if the prediction is valid), predict_taken (indicates the predicted branch direction), train_mispredicted (indicates if a branch misprediction occurred), train_taken (actual result of the branch), and train_history (history before the mispredicted branch).",
    "3. The DUT outputs predict_history, a 32-bit logic vector representing the current branch history.",
    "4. The DUT's behavior is governed by the following rules: when predict_valid is 1, predict_taken is shifted in from the LSB, updating predict_history; if train_mispredicted is 1, predict_history is loaded with train_history concatenated with train_taken; if both predict_valid and train_mispredicted are high, the former is disregarded in favor of the latter.",
    "5. The asynchronous reset (areset) resets the history to zero on the rising edge of the clock."
  ]
}
DUT header:
module top_module
(
    input clk,
    input areset,
    input predict_valid,
    input predict_taken,
    output logic [31:0] predict_history,
    
    input train_mispredicted,
    input train_taken,
    input [31:0] train_history
);


you only need to describe the stimulus in each test scenarios. If time is important, please inform the clock cycle information. we will use the stimulus description to generate the test vectors and send them to DUT. you must not tell the expected results even though you know that. 

your response must be in JSON form. example:
{
  "scenario 1": "...", # each content is a string
  "scenario 2": "...",
  "scenario 3": "...",
  ...
}


########## assistant ##########
{
  "scenario 1": "Apply an asynchronous reset signal. Set areset to 1 for one clock cycle, then set areset to 0. Observe the output for the reset state of predict_history.",
  
  "scenario 2": "Set areset to 0, then set predict_valid to 1 and predict_taken to 1. Wait for one clock cycle to observe the update in predict_history after the prediction is made (first prediction).",

  "scenario 3": "Set predict_valid to 1 and predict_taken to 0. Wait for one clock cycle. Observe the update in predict_history after the second prediction is made.",
  
  "scenario 4": "Set predict_valid to 1 and predict_taken to 1 again. Wait for one clock cycle to observe the update in predict_history with subsequent predictions.",
  
  "scenario 5": "Set predict_valid to 0, with train_mispredicted set to 1. Provide train_history with a sample value and train_taken with 1. Wait for one clock cycle. Observe the output of predict_history reflecting the update based on the misprediction.",
  
  "scenario 6": "Set both predict_valid and train_mispredicted to 1, with train_history set to specific value and train_taken set to 0. Wait for one clock cycle. Observe that the output of predict_history should reflect the misprediction state despite predict_valid being high.",
  
  "scenario 7": "Set areset to 0, then provide several cycles of predictions (e.g., predict_valid = 1, alternating predict_taken values). Wait for a total of four clock cycles. Observe the evolution of predict_history through multiple predictions.",
  
  "scenario 8": "Set areset to 0, after a series of predictions, set areset to 1 again for one clock cycle, then revert to areset = 0. Observe predict_history should revert to the initial reset state.",
  
  "scenario 9": "Provide a mix of predictions and mispredictions over several cycles (e.g., multiple cycles with varying predict_valid, train_mispredicted, predict_taken, and train_taken values), spaced by clock cycles. Observe how predict_history evolves amid these inputs."
}

