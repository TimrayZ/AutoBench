############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
Please generate the verilog RTL code according to the following description and header information:
problem description:
You are given a 100-bit input vector in[99:0]. We want to know some relationships between each bit and its neighbour: 
// (1) out_both: Each bit of this output vector should indicate whether both the corresponding input bit and its neighbour to the left are '1'. For example, out_both[98] should indicate if in[98] and in[99] are both 1. Since in[99] has no neighbour to the left, the answer is obvious so we don't need to know out_both[99]. 
// (2) out_any: Each bit of this output vector should indicate whether any of the corresponding input bit and its neighbour to the right are '1'. For example, out_any[2] should indicate if either in[2] or in[1] are 1. Since in[0] has no neighbour to the right, the answer is obvious so we don't need to know out_any[0]. 
// (3) out_different: Each bit of this output vector should indicate whether the corresponding input bit is different from its neighbour to the left. For example, out_different[98] should indicate if in[98] is different from in[99]. For this part, treat the vector as wrapping around, so in[99]'s neighbour to the left is in[0].

RTL header:
module top_module (
	input [99:0] in,
	output [98:0] out_both,
	output [99:1] out_any,
	output [99:0] out_different
);

please only reply verilog codes. reply_format:
```verilog
your_code_here...
```


########## assistant ##########
```verilog
module top_module (
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different
);

    // Generate out_both: Each bit indicates whether both in[i] and in[i+1] are '1'
    assign out_both[98] = in[98] & in[99]; // last bit computing
    genvar i;
    generate
        for (i = 0; i < 98; i = i + 1) begin : both_generator
            assign out_both[i] = in[i] & in[i + 1];
        end
    endgenerate

    // Generate out_any: Each bit indicates whether either in[i] or in[i-1] is '1'
    assign out_any[1] = in[1] | in[0]; // first bit computing
    generate
        for (i = 1; i < 99; i = i + 1) begin : any_generator
            assign out_any[i] = in[i] | in[i - 1];
        end
    endgenerate
    assign out_any[0] = 1'b0; // no neighbor for in[0]

    // Generate out_different: Each bit indicates whether in[i] is different from in[i-1]
    assign out_different[0] = in[0] ^ in[99]; // wrap around case
    generate
        for (i = 1; i < 100; i = i + 1) begin : different_generator
            assign out_different[i] = in[i] ^ in[i - 1];
        end
    endgenerate

endmodule
```

