############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########

1. Your task is to write a verilog testbench for an verilog RTL module code (we call it as "DUT", device under test). The infomation we have is 
- 1.1. the problem description that guides student to write the RTL code (DUT) and the header of the "DUT". 
- 1.2. the module header.
- 1.3. the technical specification of testbench
- 1.4. test scenarios which determines value and sequential information of test vectors

2. you are in section 4. in this section, our target is to generate the verilog testbench for the DUT. This testbench can export the input and output signals of DUT at the important time points. The exported data will be send to a python script to check the correctness of DUT. 
ATTENTION: The testbench does not need to check the DUT's output but only export the signals of DUT.
Instruction of saving signals to file: 
(1) you should use $fopen and $fdisplay to export the important signals in testbench. the file name is "TBout.txt".
(2) When running testbench, for one time point, you should export 1 line. the example of the printed line is "scenario: 1, clk = %d, resetn = %d, r = %d, g = %d"; If one scenario has multiple test cases, use letter suffix to represent different test cases, like "scenario: 1a, clk = %d, resetn = %d, r = %d, g = %d", "scenario: 1b, clk = %d, resetn = %d, r = %d, g = %d".
(3) Attention: before $fdisplay, you should always have a delay statement to make sure the signals are stable.
(4) the signals you save is the input and output of DUT, you should determine the signals according to DUT's header:

module top_module (
	input clk,
	input resetn,
	input [3:1] r,
	output [3:1] g
);

Your other information:
RTL circuit problem description:
Consider the FSM described by the state diagram shown below:

// A --r1=0,r2=0,r3=0--> A
// A --r1=1--> B
// A --r1=0,r2=1--> C
// A --r1=0,r2=0,r3=0--> D
// B (g1=1) --r1=1--> B
// B (g1=1) --r1=0--> A
// C (g2=1) --r2=1--> C
// C (g2=1) --r2=0--> A

// Resetn is an active-low synchronous reset that resets into state A. This FSM acts as an arbiter circuit, which controls access to some type of resource by three requesting devices. Each device makes its request for the resource by setting a signal _r[i]_ = 1, where _r[i]_ is either _r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and represents one of the three devices. The FSM stays in state _A_ as long as there are no requests. When one or more request occurs, then the FSM decides which device receives a grant to use the resource and changes to a state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an output from the FSM. There is a priority system, in that device 1 has a higher priority than device 2, and device 3 has the lowest priority. Hence, for example, device 3 will only receive a grant if it is the only device making a request when the FSM is in state _A_. Once a device, _i_, is given a grant by the FSM, that device continues to receive the grant as long as its request, _r[i]_ = 1.

// Write complete Verilog code that represents this FSM. Use separate always blocks for the state table and the state flip-flops, as done in lectures. Describe the FSM outputs, _g[i]_, using either continuous assignment statement(s) or an always block (at your discretion). Assign any state codes that you wish to use.
RTL testbench specification:
{
  "important data": "// A --r1=0,r2=0,r3=0--> A\n// A --r1=1--> B\n// A --r1=0,r2=1--> C\n// A --r1=0,r2=0,r3=0--> D\n// B (g1=1) --r1=1--> B\n// B (g1=1) --r1=0--> A\n// C (g2=1) --r2=1--> C\n// C (g2=1) --r2=0--> A\nResetn is an active-low synchronous reset that resets into state A.",
  "technical specifications": [
    "0: The DUT is a finite state machine (FSM) that manages requests from three devices.",
    "1: The input signals to the DUT are clock (clk) signal, active-low synchronous reset (resetn), and request signals (r[3:1]) from devices.",
    "2: The output signals from the DUT are grant signals (g[3:1]) indicating which device has been granted access.",
    "3: The FSM must implement state transitions based on the input requests while adhering to the priority: device 1 > device 2 > device 3.",
    "4: The initial state of the FSM is state A when resetn is low.",
    "5: The testbench needs to apply various combinations of the r inputs to fully test the state transitions and outputs for all defined scenarios.",
    "6: Expected result signals should match the specified FSM behavior for each test case defined in the problem description.",
    "7: The testbench will check if the output signals (g signals) match the expected values for given input scenarios."
  ]
}
IMPORTANT - test scenario:
{
  "scenario 1": "Reset the FSM by setting resetn low (0) and maintain it for 1 clock cycle. After that, set resetn high (1) and observe the initial state.",
  "scenario 2": "With resetn high (1), set r[1] to 1 (high) and r[2] and r[3] to 0 (low) for 2 clock cycles to check for state transition to device 1 grant.",
  "scenario 3": "Keep resetn high (1) and set r[2] to 1 (high) while r[1] and r[3] are low (0) for 2 clock cycles to verify state transition to device 2 grant.",
  "scenario 4": "With resetn high (1), set r[3] to 1 (high) while r[1] and r[2] are low (0) for 2 clock cycles to validate state transition for device 3 when no higher priority requests are active.",
  "scenario 5": "Set resetn high (1), and in cycle 1, set r[1] = 1 (high), r[2] = 1 (high), and r[3] = 0 (low) to test priority handling for device 1 for 3 clock cycles. Then, switch r[1] back to 0 (low) while keeping r[2] high for another 2 clock cycles to see if the FSM grants to device 2.",
  "scenario 6": "With resetn high (1), keep r[1] and r[2] low (0), set r[3] high (1) for 2 clock cycles to check return to the appropriate state after releasing device 3.",
  "scenario 7": "Set resetn high (1), and for 1 clock cycle drive r[1] = 1 (high) and r[2] = 1 (high) and r[3] = 1 (high) to test the FSM's behavior under conflicting requests and validate the priority of grants for the next 4 clock cycles.",
  "scenario 8": "With resetn high (1), cycle through combinations where all r[i] are low (0) for 3 clock cycles, confirming the FSM can return to its idle state."
}

The testbench does not need to check the DUT's output but only export the signals of DUT.
Instruction of saving signals to file: 
(1) you should use $fopen and $fdisplay to export the important signals in testbench. the file name is "TBout.txt". 
(2) When running testbench, for one time point, you should export 1 line. the example of the printed line is "scenario: 1, clk = %d, resetn = %d, r = %d, g = %d"; If one scenario has multiple test cases, use letter suffix to represent different test cases, like "scenario: 1a, clk = %d, resetn = %d, r = %d, g = %d", "scenario: 1b, clk = %d, resetn = %d, r = %d, g = %d".
(3) Attention: before $fdisplay, you should always have a delay statement to make sure the signals are stable.
(4) the signals you save is the input and output of DUT, you should determine the signals according to DUT's header.
please only generate the verilog codes, no other words.



########## assistant ##########
```verilog
`timescale 1ns / 1ps

module tb_top_module;

    // Parameters
    reg clk;
    reg resetn;
    reg [3:1] r;
    wire [3:1] g;

    // Instantiate the DUT
    top_module DUT (
        .clk(clk),
        .resetn(resetn),
        .r(r),
        .g(g)
    );

    // File Handling
    integer file;

    // Clock Generation
    initial begin
        clk = 0;
        forever #5 clk = ~clk; // 10 time units period
    end

    // Test Cases
    initial begin
        // Open the file
        file = $fopen("TBout.txt", "w");

        // Scenario 1: Reset the FSM
        resetn = 0; // Active low reset
        #10; // Wait for 1 clock cycle
        resetn = 1; // Release reset
        #10; // Wait for signals to stabilize
        $fdisplay(file, "scenario: 1, clk = %d, resetn = %d, r = %b, g = %b", clk, resetn, r, g);
        
        // Scenario 2: Device 1 grant
        r = 3'b100; // r1=1, r2=0, r3=0
        #20; // Wait for 2 clock cycles
        $fdisplay(file, "scenario: 2, clk = %d, resetn = %d, r = %b, g = %b", clk, resetn, r, g);

        // Scenario 3: Device 2 grant
        r = 3'b010; // r1=0, r2=1, r3=0
        #20; // Wait for 2 clock cycles
        $fdisplay(file, "scenario: 3, clk = %d, resetn = %d, r = %b, g = %b", clk, resetn, r, g);

        // Scenario 4: Device 3 grant
        r = 3'b001; // r1=0, r2=0, r3=1
        #20; // Wait for 2 clock cycles
        $fdisplay(file, "scenario: 4, clk = %d, resetn = %d, r = %b, g = %b", clk, resetn, r, g);

        // Scenario 5: Priority handling
        r = 3'b110; // r1=1, r2=1, r3=0
        #30; // Wait for 3 clock cycles
        $fdisplay(file, "scenario: 5, clk = %d, resetn = %d, r = %b, g = %b", clk, resetn, r, g);
        r = 3'b010; // r1=0, r2=1, r3=0
        #20; // Wait for 2 clock cycles
        $fdisplay(file, "scenario: 5a, clk = %d, resetn = %d, r = %b, g = %b", clk, resetn, r, g);

        // Scenario 6: Device 3 without higher priority
        r = 3'b001; // r1=0, r2=0, r3=1
        #20; // Wait for 2 clock cycles
        $fdisplay(file, "scenario: 6, clk = %d, resetn = %d, r = %b, g = %b", clk, resetn, r, g);

        // Scenario 7: Conflicting requests
        r = 3'b111; // r1=1, r2=1, r3=1
        #40; // Wait for 4 clock cycles
        $fdisplay(file, "scenario: 7, clk = %d, resetn = %d, r = %b, g = %b", clk, resetn, r, g);

        // Scenario 8: Idle state
        r = 3'b000; // All requests are low
        #30; // Wait for 3 clock cycles
        $fdisplay(file, "scenario: 8, clk = %d, resetn = %d, r = %b, g = %b", clk, resetn, r, g);

        // Close the file
        $fclose(file);
        $finish; // End simulation
    end

endmodule
```

