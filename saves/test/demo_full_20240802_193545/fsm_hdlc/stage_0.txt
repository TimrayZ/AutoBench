############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
Please generate the verilog RTL code according to the following description and header information:
problem description:
Synchronous HDLC framing involves decoding a continuous bit stream of data to look for bit patterns that indicate the beginning and end of frames (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a "flag" that indicate frame boundaries. To avoid the data stream from accidentally containing "flags", the sender inserts a zero after every 5 consecutive 1s which the receiver must detect and discard. We also need to signal an error if there are 7 or more consecutive 1s. Create a Moore-type finite state machine to recognize these three sequences:

// (1) 0111110: Signal a bit needs to be discarded (disc).
// (2) 01111110: Flag the beginning/end of a frame (flag).
// (3) 01111111...: Error (7 or more 1s) (err).

// When the FSM is reset, it should be in a state that behaves as though the previous input were 0. The reset signal is active high synchronous. The output signals should be asserted for a complete cycle beginning on the clock cycle after the condition occurs.
RTL header:
module top_module (
	input clk,
	input reset,
	input in,
	output disc,
	output flag,
	output err);

please only reply verilog codes. reply_format:
```verilog
your_code_here...
```


########## assistant ##########
```verilog
module top_module (
    input clk,
    input reset,
    input in,
    output reg disc,
    output reg flag,
    output reg err
);

    // State encoding
    parameter S0 = 3'b000; // Initial State
    parameter S1 = 3'b001; // One 1s
    parameter S2 = 3'b010; // Two 1s
    parameter S3 = 3'b011; // Three 1s
    parameter S4 = 3'b100; // Four 1s
    parameter S5 = 3'b101; // Five 1s
    parameter S6 = 3'b110; // Six 1s
    parameter S7 = 3'b111; // Seven or more 1s

    reg [2:0] state, next_state;

    // State Transition Logic
    always @(*) begin
        // Default outputs
        disc = 0;
        flag = 0;
        err = 0;

        case (state)
            S0: begin
                if (in == 1) 
                    next_state = S1;
                else 
                    next_state = S0;
            end
            
            S1: begin
                if (in == 1) 
                    next_state = S2;
                else 
                    next_state = S0; // 0 after 1s
            end
            
            S2: begin
                if (in == 1) 
                    next_state = S3;
                else 
                    next_state = S0; // 0 after 2s
            end
            
            S3: begin
                if (in == 1) 
                    next_state = S4;
                else 
                    next_state = S0; // 0 after 3s
            end
            
            S4: begin
                if (in == 1) 
                    next_state = S5;
                else 
                    next_state = S0; // 0 after 4s
            end
            
            S5: begin
                if (in == 1) 
                    next_state = S6; // 6 consecutive 1s
                else 
                    next_state = S0; // 0 after 5s
            end
            
            S6: begin
                if (in == 1) 
                    next_state = S7; // 7 consecutive 1s
                else 
                    next_state = S0; // 0 after 6s
            end
            
            S7: begin
                next_state = S7; // Remain in error state
                err = 1; // Set error flag
            end
            
            default: next_state = S0; // Default to reset state
        endcase
    end

    // State Update on Clock Edge
    always @(posedge clk) begin
        if (reset) begin
            state <= S0;
        end else begin
            state <= next_state;

            // Output logic for disc and flag
            if (next_state == S5) 
                disc = 1; // Discard signal for 0111110
            if (next_state == S6) 
                flag = 1; // Flag signal for 01111110
        end
    end

endmodule
```

