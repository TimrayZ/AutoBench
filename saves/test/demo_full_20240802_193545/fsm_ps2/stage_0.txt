############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
Please generate the verilog RTL code according to the following description and header information:
problem description:
The PS/2 mouse protocol sends messages that are three bytes long. However, within a continuous byte stream, it's not obvious where messages start and end. The only indication is that the first byte of each three byte message always has in[3]=1 (but in[3] of the other two bytes may be 1 or 0 depending on data). We want a finite state machine that will search for message boundaries when given an input byte stream. The algorithm we'll use is to discard bytes until we see one with in[3]=1. We then assume that this is byte 1 of a message, and signal the receipt of a message once all 3 bytes have been received (done). The FSM should signal done in the cycle immediately after the third byte of each message was successfully received. Reset should be active high synchronous.
RTL header:
module top_module (
	input clk,
	input [7:0] in,
	input reset,
	output done
);

please only reply verilog codes. reply_format:
```verilog
your_code_here...
```


########## assistant ##########
```verilog
module top_module (
    input clk,
    input [7:0] in,
    input reset,
    output reg done
);

    typedef enum logic [1:0] {
        IDLE,   // Waiting for the start byte
        BYTE1,  // First byte received
        BYTE2,  // Second byte received
        BYTE3   // Third byte received
    } state_t;

    state_t current_state, next_state;

    always_ff @(posedge clk) begin
        if (reset) begin
            current_state <= IDLE;
            done <= 0;
        end else begin
            current_state <= next_state;
        end
    end

    always_ff @(posedge clk) begin
        if (reset) begin
            done <= 0;
        end else begin
            case (current_state)
                BYTE3: begin
                    done <= 1;  // Signal done after third byte
                end
                default: begin
                    done <= 0;
                end
            endcase
        end
    end

    always_comb begin
        case (current_state)
            IDLE: begin
                if (in[3] == 1) 
                    next_state = BYTE1;  // Move to BYTE1 when in[3] = 1
                else 
                    next_state = IDLE;   // Stay in IDLE if not found
            end
            
            BYTE1: begin
                next_state = BYTE2;  // Always move to BYTE2 once BYTE1 is received
            end
            
            BYTE2: begin
                next_state = BYTE3;  // Move to BYTE3 after receiving BYTE2
            end
            
            BYTE3: begin
                next_state = IDLE;   // Go back to IDLE after BYTE3
            end
            
            default: next_state = IDLE; // Default case to prevent latches
        endcase
    end

endmodule
```

