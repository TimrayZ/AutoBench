############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########

1. Your task is to write a verilog testbench for an verilog RTL module code (we call it as "DUT", device under test). The infomation we have is 
- 1.1. the problem description that guides student to write the RTL code (DUT) and the header of the "DUT". 
- 1.2. the module header.
- 1.3. the technical specification of testbench
- 1.4. test scenarios which determines value and sequential information of test vectors

2. you are in section 4. in this section, our target is to generate the verilog testbench for the DUT. This testbench can export the input and output signals of DUT at the important time points. The exported data will be send to a python script to check the correctness of DUT. 
ATTENTION: The testbench does not need to check the DUT's output but only export the signals of DUT.
Instruction of saving signals to file: 
(1) you should use $fopen and $fdisplay to export the important signals in testbench. the file name is "TBout.txt".
(2) When running testbench, for one time point, you should export 1 line. the example of the printed line is "scenario: 1, in = %d, out = %d"; If one scenario has multiple test cases, use letter suffix to represent different test cases, like "scenario: 1a, in = %d, out = %d", "scenario: 1b, in = %d, out = %d".
(3) Attention: before $fdisplay, you should always have a delay statement to make sure the signals are stable.
(4) the signals you save is the input and output of DUT, you should determine the signals according to DUT's header:

module top_module (
	input [254:0] in,
	output reg [7:0] out
);

Your other information:
RTL circuit problem description:
A "population count" circuit counts the number of '1's in an input vector. Build a population count circuit for a 255-bit input vector.
RTL testbench specification:
{
  "important data": "Population count circuit counts the number of '1's in a 255-bit input vector.",
  "technical specifications": [
    "1: DUT module header is 'module top_module (input [254:0] in, output reg [7:0] out);'",
    "2: The input 'in' is a 255-bit vector (254:0).",
    "3: The output 'out' is an 8-bit register (7:0) representing the number of '1's in the input vector.",
    "4: The expected output range for the 'out' signal is from 0 to 255, as the maximum number of '1's in a 255-bit vector is 255."
  ]
}
IMPORTANT - test scenario:
{
  "scenario 1": "Set the input 'in' to all zeroes (255'b0) for 1 clock cycle to check the output when no bits are set.",
  "scenario 2": "Set the input 'in' to all ones (255'b1) for 1 clock cycle to check the output when all bits are set.",
  "scenario 3": "Set the input 'in' to a vector of 127 ones followed by 128 zeroes (255'b011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111) for 1 clock cycle to check the output for half-set bits.",
  "scenario 4": "Set the input 'in' to 1 followed by 254 zeroes (255'b1 followed by 254'b0) for 1 clock cycle to check the output for a single set bit.",
  "scenario 5": "Set the input 'in' to a random pattern such as (255'b101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101) for 1 clock cycle to check the output when alternating bits are set.",
  "scenario 6": "Set the input 'in' to a vector with 255 bits set in random positions, agreeing that it has 200 instances of '1' (for 1 clock cycle) to check the output with a non-uniform distribution of bits.",
  "scenario 7": "Set the input 'in' to a vector with 255 bits set in random positions, agreeing that it will yield exactly 0 ones (for 1 clock cycle) after having set previously to (255'b0) to check how DUT handles successive inputs."
}

The testbench does not need to check the DUT's output but only export the signals of DUT.
Instruction of saving signals to file: 
(1) you should use $fopen and $fdisplay to export the important signals in testbench. the file name is "TBout.txt". 
(2) When running testbench, for one time point, you should export 1 line. the example of the printed line is "scenario: 1, in = %d, out = %d"; If one scenario has multiple test cases, use letter suffix to represent different test cases, like "scenario: 1a, in = %d, out = %d", "scenario: 1b, in = %d, out = %d".
(3) Attention: before $fdisplay, you should always have a delay statement to make sure the signals are stable.
(4) the signals you save is the input and output of DUT, you should determine the signals according to DUT's header.
please only generate the verilog codes, no other words.



########## assistant ##########
```verilog
`timescale 1ns/1ps

module tb_top_module;

  reg [254:0] in;
  wire [7:0] out;
  
  // Instantiate the Device Under Test (DUT)
  top_module DUT (
    .in(in),
    .out(out)
  );
  
  integer file;

  initial begin
    // Open the file for writing
    file = $fopen("TBout.txt", "w");
    
    // Scenario 1: All zeroes
    in = 255'b0;
    #1; // Wait for signal stabilization
    $fdisplay(file, "scenario: 1, in = %b, out = %d", in, out);
    
    // Scenario 2: All ones
    in = 255'b1;
    #1; // Wait for signal stabilization
    $fdisplay(file, "scenario: 2, in = %b, out = %d", in, out);
    
    // Scenario 3: 127 ones followed by 128 zeroes
    in = 255'b0111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111;
    #1; // Wait for signal stabilization
    $fdisplay(file, "scenario: 3, in = %b, out = %d", in, out);
    
    // Scenario 4: Single set bit
    in = 255'b1;
    #1; // Wait for signal stabilization
    $fdisplay(file, "scenario: 4, in = %b, out = %d", in, out);
    
    // Scenario 5: Alternating bits
    in = 255'b101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101;
    #1; // Wait for signal stabilization
    $fdisplay(file, "scenario: 5, in = %b, out = %d", in, out);
    
    // Scenario 6: Random pattern with 200 ones (example hardcoded)
    in = 255'b110101001000000011101011100111101011000010001010110010101110011010101011101011010001101000010101101000101101010;
    #1; // Wait for signal stabilization
    $fdisplay(file, "scenario: 6, in = %b, out = %d", in, out);
    
    // Scenario 7: All zeroes after previous
    in = 255'b0;
    #1; // Wait for signal stabilization
    $fdisplay(file, "scenario: 7, in = %b, out = %d", in, out);
    
    // Close the file
    $fclose(file);
    
    $finish; // End simulation
  end

endmodule
```

