############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
1. Your task is to write a verilog testbench for an verilog RTL module code (we call it as "DUT", device under test). The infomation we have is the problem description that guides student to write the RTL code (DUT) and the header of the "DUT". Our target is to generate the verilog testbench for the DUT. This testbench can check if the DUT in verilog satisfies all technical requirements of the problem description.
2. you are in section 2. in this section, please give me the test scenarios. you only need to describe the stimulus in each test scenarios. If time is important, please inform the clock cycle information. we will use the stimulus description to generate the test vectors and send them to DUT. you must not tell the expected results even though you know that. 
3. your information is:
RTL circuit problem description:
Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. 
// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. 
// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.
// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.
RTL testbench specification:
{
  "important data": "The branch predictor requires the management of a 7-bit program counter (PC) and a 7-bit global history register, hashed into a 7-bit index to access a 128-entry table of two-bit saturating counters. The predictor uses a prediction interface for predicting branch direction and a training interface for training based on actual branch outcomes. Reset is asynchronous active-high.",
  "technical specifications": [
    "1: The DUT will have input signals: clk, areset, predict_valid, predict_pc, train_valid, train_taken, train_mispredicted, train_history, and train_pc.",
    "2: The DUT will have output signals: predict_taken and predict_history.",
    "3: The testbench should initialize the DUT and apply test cases for both prediction and training sequences, ensuring to cover scenarios including correct predictions, mispredictions, and simultaneous prediction and training events.",
    "4: Every test case must check that the output signals from the DUT match the expected results based on the inputs provided to it.",
    "5: The testbench must handle the asynchronous reset functionality and create specific scenarios to validate its effectiveness.",
    "6: Timing requirements must be adhered to, ensuring that predictions do not use the updated PHT state until the subsequent clock edge after training."
  ]
}
DUT header:
module top_module(
	input clk,
	input areset, 

	input predict_valid,
	input [6:0] predict_pc,
	output predict_taken, 
	output [6:0] predict_history,

	input train_valid,
	input train_taken,
	input train_mispredicted,
	input [6:0] train_history, 
	input [6:0] train_pc
);


you only need to describe the stimulus in each test scenarios. If time is important, please inform the clock cycle information. we will use the stimulus description to generate the test vectors and send them to DUT. you must not tell the expected results even though you know that. 

your response must be in JSON form. example:
{
  "scenario 1": "...", # each content is a string
  "scenario 2": "...",
  "scenario 3": "...",
  ...
}


########## assistant ##########
{
  "scenario 1": "Reset the DUT by asserting areset high for one clock cycle. Deassert areset at the next clock cycle. This scenario checks if the DUT correctly initializes the internal state after a reset.",
  
  "scenario 2": "At clock cycle 2, assert predict_valid and provide a valid 7-bit predict_pc (e.g., 0b0000001). Observe predict_taken and predict_history outputs. Ensure no train_valid signal is asserted at this time.",
  
  "scenario 3": "At clock cycle 3, assert train_valid to train the predictor with train_pc set to the same value as predict_pc from scenario 2, train_taken high, and train_mispredicted low. Observe the outputs and confirm they remain stable until the next clock edge.",
  
  "scenario 4": "At clock cycle 4, assert both predict_valid with a new predict_pc (e.g., 0b0000010) and train_valid to train the same train_pc (from scenario 3). Ensure that the prediction for predict_taken corresponds to the old PHT state while the PHT is updated at the next clock edge.",
  
  "scenario 5": "At clock cycle 5, assert predict_valid again with a new 7-bit predict_pc (e.g., 0b0000001). Observe predict_taken and predict_history outputs to check for proper prediction after training from the previous cycle.",
  
  "scenario 6": "Another training scenario: At clock cycle 6, assert train_valid with train_pc equal to a previously used predict_pc (from scenario 5), set train_taken low, and train_mispredicted high. Confirm the DUT can handle the misprediction correctly.",
  
  "scenario 7": "At clock cycle 7, assert both predict_valid with a different predict_pc (e.g., 0b0000011) and train_valid at the same time with a new train_pc (e.g., 0b0000001); train_taken high and train_mispredicted low. Observe the behavior of outputs in handling simultaneous prediction and training.",
  
  "scenario 8": "At clock cycle 8, keep train_valid asserted and change train_pc to a new value (e.g., 0b0000010), ensure train_taken is low and train_mispredicted is high to verify misprediction handling after a prediction was already processed.",
  
  "scenario 9": "At clock cycle 9, reset the DUT again by asserting areset high and maintaining it for one clock cycle to check the DUT's response and stability after a second reset.",
  
  "scenario 10": "At clock cycle 10, assert predict_valid with a new predict_pc (e.g., 0b0000011) while areset is no longer asserted. Observe whether the outputs are stable and correct after reset."
}

