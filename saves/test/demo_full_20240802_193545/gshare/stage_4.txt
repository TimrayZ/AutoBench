############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########

1. Your task is to complete a given verilog testbench code. This testbench is for a verilog RTL module code (we call it as "DUT", device under test). This circuit is a sequential circuit. The infomation we have is 
- 1.1. the problem description that guides student to write the RTL code (DUT) and the header of the "DUT". 
- 1.2. the module header.
- 1.3. test scenarios which determines values and sequential information of test vectors
- 1.4. the testbench structure
- 1.5. the instruction of writing our testbench

DUT header:
module top_module(
	input clk,
	input areset, 

	input predict_valid,
	input [6:0] predict_pc,
	output predict_taken, 
	output [6:0] predict_history,

	input train_valid,
	input train_taken,
	input train_mispredicted,
	input [6:0] train_history, 
	input [6:0] train_pc
);

Your other information:
RTL circuit problem description:
Build a gshare branch predictor with 7-bit pc and 7-bit global history, hashed (using xor) into a 7-bit index. This index accesses a 128-entry table of two-bit saturating counters. The branch predictor should contain a 7-bit global branch history register. The branch predictor has two sets of interfaces: One for doing predictions and one for doing training. The prediction interface is used in the processor's Fetch stage to ask the branch predictor for branch direction predictions for the instructions being fetched. Once these branches proceed down the pipeline and are executed, the true outcomes of the branches become known. The branch predictor is then trained using the actual branch direction outcomes. 
// When a branch prediction is requested (predict_valid = 1) for a given pc, the branch predictor produces the predicted branch direction and state of the branch history register used to make the prediction. The branch history register is then updated (at the next positive clock edge) for the predicted branch. 
// When training for a branch is requested (train_valid = 1), the branch predictor is told the pc and branch history register value for the branch that is being trained, as well as the actual branch outcome and whether the branch was a misprediction (needing a pipeline flush). Update the pattern history table (PHT) to train the branch predictor to predict this branch more accurately next time. In addition, if the branch being trained is mispredicted, also recover the branch history register to the state immediately after the mispredicting branch completes execution.
// If training for a misprediction and a prediction (for a different, younger instruction) occurs in the same cycle, both operations will want to modify the branch history register. When this happens, training takes precedence, because the branch being predicted will be discarded anyway. If training and prediction of the same PHT entry happen at the same time, the prediction sees the PHT state before training because training only modifies the PHT at the next positive clock edge. The following timing diagram shows the timing when training and predicting PHT entry 0 at the same time. The training request at cycle 4 changes the PHT entry state in cycle 5, but the prediction request in cycle 4 outputs the PHT state at cycle 4, without considering the effect of the training request in cycle 4. Reset is asynchronous active-high.
IMPORTANT - test scenario (Please determine the values of input signals according to these test scenarios.):
{
  "scenario 1": "Reset the DUT by asserting areset high for one clock cycle. Deassert areset at the next clock cycle. This scenario checks if the DUT correctly initializes the internal state after a reset.",
  
  "scenario 2": "At clock cycle 2, assert predict_valid and provide a valid 7-bit predict_pc (e.g., 0b0000001). Observe predict_taken and predict_history outputs. Ensure no train_valid signal is asserted at this time.",
  
  "scenario 3": "At clock cycle 3, assert train_valid to train the predictor with train_pc set to the same value as predict_pc from scenario 2, train_taken high, and train_mispredicted low. Observe the outputs and confirm they remain stable until the next clock edge.",
  
  "scenario 4": "At clock cycle 4, assert both predict_valid with a new predict_pc (e.g., 0b0000010) and train_valid to train the same train_pc (from scenario 3). Ensure that the prediction for predict_taken corresponds to the old PHT state while the PHT is updated at the next clock edge.",
  
  "scenario 5": "At clock cycle 5, assert predict_valid again with a new 7-bit predict_pc (e.g., 0b0000001). Observe predict_taken and predict_history outputs to check for proper prediction after training from the previous cycle.",
  
  "scenario 6": "Another training scenario: At clock cycle 6, assert train_valid with train_pc equal to a previously used predict_pc (from scenario 5), set train_taken low, and train_mispredicted high. Confirm the DUT can handle the misprediction correctly.",
  
  "scenario 7": "At clock cycle 7, assert both predict_valid with a different predict_pc (e.g., 0b0000011) and train_valid at the same time with a new train_pc (e.g., 0b0000001); train_taken high and train_mispredicted low. Observe the behavior of outputs in handling simultaneous prediction and training.",
  
  "scenario 8": "At clock cycle 8, keep train_valid asserted and change train_pc to a new value (e.g., 0b0000010), ensure train_taken is low and train_mispredicted is high to verify misprediction handling after a prediction was already processed.",
  
  "scenario 9": "At clock cycle 9, reset the DUT again by asserting areset high and maintaining it for one clock cycle to check the DUT's response and stability after a second reset.",
  
  "scenario 10": "At clock cycle 10, assert predict_valid with a new predict_pc (e.g., 0b0000011) while areset is no longer asserted. Observe whether the outputs are stable and correct after reset."
}
below is the given testbench codes:
`timescale 1ns / 1ps
module testbench;
reg  clk;
reg  areset;
reg  predict_valid;
reg [6:0] predict_pc;
wire  predict_taken;
wire [6:0] predict_history;
reg  train_valid;
reg  train_taken;
reg  train_mispredicted;
reg [6:0] train_history;
reg [6:0] train_pc;

integer file, scenario;
// DUT instantiation
top_module DUT (
	.clk(clk),
	.areset(areset),
	.predict_valid(predict_valid),
	.predict_pc(predict_pc),
	.predict_taken(predict_taken),
	.predict_history(predict_history),
	.train_valid(train_valid),
	.train_taken(train_taken),
	.train_mispredicted(train_mispredicted),
	.train_history(train_history),
	.train_pc(train_pc)
);
// Clock generation
initial begin
    clk = 0;
    forever #5 clk = ~clk;
end

initial begin
    file = $fopen("TBout.txt", "w");
end
// Scenario Based Test
initial begin

    // write your scenario checking codes here, according to scenario information

    $fclose(file);
    $finish;
end

endmodule


The testbench does not need to check the DUT's output but only export the signals of DUT. Please export the signals of DUT to a file named "TBout.txt" at the end of each scenario. The template is given below:
$fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
The variables are already declared. The clock signal is already prepared. This output will be used to check the correctness of the DUT's output later.
please only use "#10" as the delay when you need. If you need longer delay, you can use multiple "#10", such as "#10; #10; #10;". Avoid meaningless long delay in your code.
If you need a loop in a scenario to check multiple time points, use "repeat" loop. for exmaple:
```
// scenario x
scenario = x;
signal_1 = 1;
repeat(5) begin
    $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
    #10;
end
```
Please determine the input signal's exact values according to given test scenarios. 
Note: please complete the last initial code part (marked in the given testbench template). You should give me the completed full code. The testbench template above is to help you generate the code. You must use %d when exporting values.
please generate the full testbench code. please only reply verilog codes, no other words. 



########## assistant ##########
```verilog
`timescale 1ns / 1ps
module testbench;
reg  clk;
reg  areset;
reg  predict_valid;
reg [6:0] predict_pc;
wire  predict_taken;
wire [6:0] predict_history;
reg  train_valid;
reg  train_taken;
reg  train_mispredicted;
reg [6:0] train_history;
reg [6:0] train_pc;

integer file, scenario;

// DUT instantiation
top_module DUT (
    .clk(clk),
    .areset(areset),
    .predict_valid(predict_valid),
    .predict_pc(predict_pc),
    .predict_taken(predict_taken),
    .predict_history(predict_history),
    .train_valid(train_valid),
    .train_taken(train_taken),
    .train_mispredicted(train_mispredicted),
    .train_history(train_history),
    .train_pc(train_pc)
);

// Clock generation
initial begin
    clk = 0;
    forever #5 clk = ~clk;
end

initial begin
    file = $fopen("TBout.txt", "w");
end

// Scenario Based Test
initial begin

    // Scenario 1
    scenario = 1;
    areset = 1;
    #10;
    areset = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    // Scenario 2
    scenario = 2;
    predict_valid = 1;
    predict_pc = 7'b0000001;
    #10;
    predict_valid = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    // Scenario 3
    scenario = 3;
    train_valid = 1;
    train_pc = 7'b0000001;
    train_taken = 1;
    train_mispredicted = 0;
    #10;
    train_valid = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    // Scenario 4
    scenario = 4;
    predict_valid = 1;
    predict_pc = 7'b0000010;
    train_valid = 1;
    train_pc = 7'b0000001;
    #10;
    train_valid = 0;
    predict_valid = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    // Scenario 5
    scenario = 5;
    predict_valid = 1;
    predict_pc = 7'b0000001;
    #10;
    predict_valid = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    // Scenario 6
    scenario = 6;
    train_valid = 1;
    train_pc = 7'b0000001;
    train_taken = 0;
    train_mispredicted = 1;
    #10;
    train_valid = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    // Scenario 7
    scenario = 7;
    predict_valid = 1;
    predict_pc = 7'b0000011;
    train_valid = 1;
    train_pc = 7'b0000001;
    train_taken = 1;
    train_mispredicted = 0;
    #10;
    train_valid = 0;
    predict_valid = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    // Scenario 8
    scenario = 8;
    train_valid = 1;
    train_pc = 7'b0000010;
    train_taken = 0;
    train_mispredicted = 1;
    #10;
    train_valid = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    // Scenario 9
    scenario = 9;
    areset = 1;
    #10;
    areset = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    // Scenario 10
    scenario = 10;
    predict_valid = 1;
    predict_pc = 7'b0000011;
    #10;
    predict_valid = 0;
    repeat(5) begin
        $fdisplay(file, "[check]scenario: %d, clk = %d, areset = %d, predict_valid = %d, predict_pc = %d, predict_taken = %d, predict_history = %d, train_valid = %d, train_taken = %d, train_mispredicted = %d, train_history = %d, train_pc = %d", scenario, clk, areset, predict_valid, predict_pc, predict_taken, predict_history, train_valid, train_taken, train_mispredicted, train_history, train_pc);
        #10;
    end

    $fclose(file);
    $finish;
end

endmodule
```

