############################## conversation begin ##############################
########## system ##########
You are the strongest AI in the world. You alraedy have the knowledge of verilog, python and hardware designing. Do not save words by discarding information. I will tip you 200$ if you can fullfill the tasks I give you.

########## user ##########
Please generate the verilog RTL code according to the following description and header information:
problem description:
Implement a Mealy-type finite state machine that recognizes the sequence "101" on an input signal named x. Your FSM should have an output signal, z, that is asserted to logic-1 when the "101" sequence is detected. Your FSM should also have a negative edge triggered asynchronous reset. You may only have 3 states in your state machine. Your FSM should recognize overlapping sequences.
RTL header:
module top_module (
	input clk,
	input aresetn,
	input x,
	output reg z
);

please only reply verilog codes. reply_format:
```verilog
your_code_here...
```


########## assistant ##########
```verilog
module top_module (
    input clk,
    input aresetn,
    input x,
    output reg z
);

    // State Encoding
    typedef enum reg [1:0] {S0, S1, S2} state_t;
    state_t current_state, next_state;

    // State Transition
    always @(posedge clk or negedge aresetn) begin
        if (!aresetn)
            current_state <= S0;
        else
            current_state <= next_state;
    end

    // Next State Logic
    always @(*) begin
        case (current_state)
            S0: begin
                if (x) next_state = S1; // x = 1, move to S1
                else next_state = S0;    // x = 0, stay in S0
            end
            S1: begin
                if (!x) next_state = S2; // x = 0, move to S2
                else next_state = S1;    // x = 1, stay in S1
            end
            S2: begin
                if (x) begin
                    next_state = S1;      // x = 1, move back to S1 (overlapping)
                    z = 1;                // Output z is asserted
                end
                else begin
                    next_state = S0;      // x = 0, move back to S0
                    z = 0;                // Output z is deasserted
                end
            end
            default: begin
                next_state = S0;        // Default state
                z = 0;                  // Default output
            end
        endcase
    end

    // Output Logic
    always @(posedge clk or negedge aresetn) begin
        if (!aresetn)
            z <= 0;                  // On reset, assert z to 0
        else if (current_state == S2 && x)
            z <= 1;                  // Set z when in S2 and x = 1
        else
            z <= 0;                  // Reset z otherwise
    end

endmodule
```

